{"id":"meshtopo-1","title":"Security: Encrypt sensitive information storage","description":"Sensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\n\nRecommendation:\n- Ensure that sensitive information is always encrypted before being stored\n- If possible, avoid placing sensitive information in cookies altogether\n- Instead, prefer storing a key in the cookie that can be used to look up the sensitive information\n- Decrypt sensitive information only at the point where it is necessary for it to be used in cleartext\n- Be aware that external processes often store the standard out and standard error streams of the application, causing logged sensitive information to be stored as well\n\nExample vulnerability:\nCode that stores user credentials (password) in a cookie in plain text should be avoided. Instead, credentials should be encrypted using the cryptography module, or not stored at all.\n\nReferences:\n- CWE-312: Cleartext Storage of Sensitive Information\n- CWE-315: Cleartext Storage of Sensitive Information in a Cookie\n- CWE-359: Exposure of Private Information (Privacy Leak)","notes":"Sensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\n\nRecommendation:\n- Ensure that sensitive information is always encrypted before being stored\n- If possible, avoid placing sensitive information in cookies altogether\n- Instead, prefer storing a key in the cookie that can be used to look up the sensitive information\n- Decrypt sensitive information only at the point where it is necessary for it to be used in cleartext\n- Be aware that external processes often store the standard out and standard error streams of the application, causing logged sensitive information to be stored as well\n\nExample vulnerability:\nCode that stores user credentials (password) in a cookie in plain text should be avoided. Instead, credentials should be encrypted using the cryptography module, or not stored at all.\n\nSpecific code location requiring attention:\nscripts/generate_mosquitto_config.py lines 116-119:\nfor user in broker_config.users:\n    if user.username and user.password:\n        hashed_password = generate_mosquitto_password(user.password)\n        f.write(f'{user.username}:{hashed_password}')\n\nThis code processes user passwords and writes them to a file. While the passwords are hashed before storage, the original plaintext passwords are handled in memory and could potentially be logged or exposed through error messages or debugging output.\n\nReferences:\n- CWE-312: Cleartext Storage of Sensitive Information\n- CWE-315: Cleartext Storage of Sensitive Information in a Cookie\n- CWE-359: Exposure of Private Information (Privacy Leak)","status":"open","priority":0,"issue_type":"bug","created_at":"2025-10-13T14:19:38.835717498-08:00","updated_at":"2025-10-13T14:22:53.90054654-08:00"}
{"id":"meshtopo-2","title":"Fix Mosquitto config template engine mismatch","description":"There is a critical issue in how the Mosquitto configuration is generated. The script uses simple string replacement, but the template file (deploy/mosquitto.conf.template) contains conditional logic (e.g., {% if ... %}). This logic will not be processed and will be written literally into the output mosquitto.conf file, making it invalid.\n\nCurrent Problem:\n- scripts/generate_mosquitto_config.py lines 84-104 use basic string replacement\n- deploy/mosquitto.conf.template contains Jinja2-style conditional logic\n- Template syntax like {% if ... %} is not processed, resulting in invalid config\n\nImpact:\n- Generated mosquitto.conf files are invalid due to unprocessed template syntax\n- Mosquitto broker may fail to start or behave unexpectedly\n- Configuration generation process produces broken output files\n\nSolution:\nReplace simple string replacement with proper Jinja2 templating engine:\n\n1. Add Jinja2 to requirements.txt\n2. Modify generate_mosquitto_config function to use Jinja2:\n   \n\n3. Update template file to use proper Jinja2 syntax\n4. Test generated configuration files for validity\n\nThis will ensure that conditional logic in templates is properly processed and valid Mosquitto configuration files are generated.","status":"open","priority":0,"issue_type":"bug","created_at":"2025-10-13T14:24:42.020908689-08:00","updated_at":"2025-10-13T14:24:42.020908689-08:00"}
{"id":"meshtopo-3","title":"Refactor Makefile: Extract duplicated REPO variable logic","description":"The shell logic to determine the REPO variable based on the GITHUB_REPOSITORY environment variable is duplicated in the docker-build (lines 93-98) and docker-pull (lines 107-112) targets. This violates the DRY (Don't Repeat Yourself) principle and makes the Makefile harder to maintain.\n\nCurrent Problem:\n- Makefile lines 93-98: REPO variable logic in docker-build target\n- Makefile lines 107-112: Identical REPO variable logic in docker-pull target\n- Code duplication makes maintenance difficult\n- Changes need to be made in multiple places\n\nImpact:\n- Violates DRY principle\n- Increases maintenance burden\n- Risk of inconsistencies if logic is updated in only one location\n- Makes Makefile harder to read and understand\n\nSolution:\nExtract the duplicated logic into a Makefile variable defined at the top of the file:\n\n1. Define REPO variable at the top of the Makefile using shell logic\n2. Remove the duplicated shell logic from both targets\n3. Use the REPO variable directly in docker-build and docker-pull targets\n\nBenefits:\n- Single source of truth for REPO variable logic\n- Easier to maintain and modify\n- Consistent behavior across all targets\n- Cleaner, more readable Makefile","status":"open","priority":2,"issue_type":"bug","created_at":"2025-10-13T14:26:07.994627712-08:00","updated_at":"2025-10-13T14:26:07.994627712-08:00"}
{"id":"meshtopo-4","title":"Optimize Docker build: Use single build with multiple tags","description":"The docker-build target builds the Docker image twice, once for the latest tag and once for the git commit hash tag. This is inefficient as it runs the entire build process two times.\n\nCurrent Problem:\n- Makefile lines 99-100: Docker image is built twice\n- First build: tags image as 'latest'\n- Second build: tags image with git commit hash\n- Entire build process runs twice, wasting time and resources\n\nImpact:\n- Inefficient use of build time and resources\n- Slower CI/CD pipeline execution\n- Unnecessary Docker layer caching misses\n- Increased build costs in cloud environments\n\nSolution:\nBuild the image once and apply multiple tags in a single command using the -t flag multiple times:\n\n\n\nBenefits:\n- Single build process instead of two\n- Faster build times\n- Better Docker layer caching utilization\n- Reduced resource consumption\n- More efficient CI/CD pipeline","status":"open","priority":1,"issue_type":"bug","created_at":"2025-10-13T14:26:53.040602485-08:00","updated_at":"2025-10-13T14:26:53.040602485-08:00"}
{"id":"meshtopo-5","title":"Remove duplicate heading in README.md","description":"The heading 'The service is configured via config/config.yaml' is redundant. It appears on line 139 and is repeated elsewhere in the document. Removing this duplicate heading will improve the document's readability.\n\nCurrent Problem:\n- README.md contains duplicate heading 'The service is configured via config/config.yaml'\n- First occurrence: line 139\n- Second occurrence: repeated elsewhere in the document\n- Redundant headings reduce document clarity and professionalism\n\nImpact:\n- Confuses readers about document structure\n- Reduces readability and flow\n- Makes the document appear unpolished\n- Violates good documentation practices\n\nSolution:\n1. Identify all occurrences of the duplicate heading\n2. Remove the redundant instance(s)\n3. Ensure the remaining heading is in the most appropriate location\n4. Verify document structure remains logical and clear\n\nBenefits:\n- Cleaner, more professional documentation\n- Improved readability and user experience\n- Better document structure and flow\n- Follows documentation best practices","status":"open","priority":3,"issue_type":"bug","created_at":"2025-10-13T14:27:26.68124449-08:00","updated_at":"2025-10-13T14:27:26.68124449-08:00"}
{"id":"meshtopo-6","title":"Improve variable naming clarity in config.py","description":"The from field in a Meshtastic message is a numeric node ID, not the hardware ID string. The logic correctly handles this by looking up the hardware ID in self.node_id_mapping, but the variable name node_id is ambiguous here as it holds the numeric ID.\n\nCurrent Problem:\n- config/config.py line 175: Variable named 'node_id' actually contains numeric ID\n- Variable name is ambiguous and doesn't clearly indicate it's numeric\n- Could be confused with hardware ID string (e.g., !a1b2c3d4)\n- Code logic is correct but naming could be clearer\n\nImpact:\n- Reduces code readability and maintainability\n- May confuse developers about data types\n- Makes code harder to understand for new contributors\n- Variable name doesn't accurately reflect its content\n\nSolution:\nRename the variable to better reflect its actual content:\n\n1. Change 'node_id' to 'numeric_node_id' on line 175\n2. Update any related comments or documentation\n3. Ensure the change improves code clarity without breaking functionality\n\nBenefits:\n- Clearer variable naming that reflects actual data type\n- Improved code readability and maintainability\n- Better distinction between numeric node ID and hardware ID string\n- Easier for developers to understand the code flow","status":"open","priority":3,"issue_type":"bug","created_at":"2025-10-13T14:28:36.193617598-08:00","updated_at":"2025-10-13T14:28:36.193617598-08:00"}
{"id":"meshtopo-7","title":"Fix critical security bug: Assertions bypassed and policy misplaced","description":"The _process_position_message function uses assert for runtime validation of sender type and hardware_id presence. These assertions can be stripped in production, leading to unexpected behavior. Additionally, the allow_unknown_devices policy check is misplaced, allowing unknown devices to bypass access control if their callsign is already mapped.\n\nCurrent Problems:\n1. Assertions used for runtime validation (src/gateway_app.py lines 251-254)\n   - assert statements can be stripped in production builds\n   - Runtime validation becomes ineffective\n   - Unexpected behavior when assertions are disabled\n\n2. Misplaced policy check for allow_unknown_devices\n   - Unknown devices can bypass access control\n   - Security policy not properly enforced\n   - Potential unauthorized access\n\nImpact:\n- Critical security vulnerability\n- Production builds may behave differently than development\n- Unauthorized devices could gain access\n- System reliability compromised\n\nSolution:\n1. Replace assert statements with proper runtime validation:\n   - Use if statements with appropriate error handling\n   - Log validation failures\n   - Return early or raise exceptions as needed\n\n2. Fix policy check placement:\n   - Ensure allow_unknown_devices check happens before any processing\n   - Properly validate device authorization\n   - Maintain security boundaries\n\n3. Add comprehensive logging for security events\n4. Test both development and production builds\n\nReferences:\n- Cursor bot review: src/gateway_app.py#L251-L254\n- Additional locations: src/gateway_app.py#L251-L254","status":"open","priority":0,"issue_type":"bug","created_at":"2025-10-13T14:29:20.53374978-08:00","updated_at":"2025-10-13T14:29:20.53374978-08:00"}
